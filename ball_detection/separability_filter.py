# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_separability_filter.ipynb (unless otherwise specified).

__all__ = ['conv2d', 'cvtIntegralImage', 'cvtCombSimpRectFilter', 'tmpFnc']

# Cell
import torch as t
import torch.nn.functional as F

from .utils import plot_images

# Cell
def conv2d(X, W, normalize_weights=True, **kwargs):
    # Do stuff on the input tensor
    X = t.FloatTensor(X)
    if X.ndim==2:
        X = X.view(1, 1, *X.shape)
    elif X.ndim==3:
        X = X.view(1, *X.shape)
    else:
        assert X.ndim==4

    # Do stuff on the weights
    c = X.shape[1]
    W = t.FloatTensor(W)
    h, w = W.shape[-2:]
    W = W.view(1, 1, h, w).repeat(c,1,1,1)
    c = X.shape[1]
    Y = F.conv2d(X, W, groups=c, **kwargs)
    return Y

# Cell
import numpy as np

def cvtIntegralImage(X):
    H, W = X.shape
    Z = np.zeros((H+1, W+1), np.float64)
    Z[1:,1:] = np.cumsum(np.cumsum(X,0),1)
    return Z

def cvtCombSimpRectFilter(I,P,sh):
    bh = sh*2
    bw = np.ceil(sh/3).astype(np.int64)
    sw = np.ceil(sh/3).astype(np.int64)
    dh = 0
    dw = 0

    MAP   = np.zeros((I.shape[0]-1, I.shape[1]-1, 2), np.float64)

    MAP[:,:,0] = tmpFnc(I,P,bh,bw,sh,sw,dh,dw)
    MAP[:,:,1] = tmpFnc(I,P,bw,bh,sw,sh,dh,dw)

    return MAP

def tmpFnc(I,P,bh,bw,sh,sw,dh,dw):
    MAP   = np.zeros((I.shape[0]-1, I.shape[1]-1), np.float64)
    H,W = MAP.shape
    r = np.max([bh,bw])
    N  = (2*bh+1)*(2*bw+1)
    N1 = (2*sh+1)*(2*sw+1)
    N2 = N-N1

    S = (
        I[r -bh  :H-r -bh   ,r -bw  :W-r -bw  ]
      + I[r +bh+1:H-r +bh+1 ,r +bw+1:W-r +bw+1]
      - I[r -bh  :H-r -bh   ,r +bw+1:W-r +bw+1]
      - I[r +bh+1:H-r +bh+1 ,r -bw  :W-r -bw  ]
    )
    T = (
        P[r -bh  :H-r -bh   ,r -bw  :W-r -bw  ]
      + P[r +bh+1:H-r +bh+1 ,r +bw+1:W-r +bw+1]
      - P[r -bh  :H-r -bh   ,r +bw+1:W-r +bw+1]
      - P[r +bh+1:H-r +bh+1 ,r -bw  :W-r -bw  ]
    )
    M = S/N
    Y = T/N
    St = Y - np.power(M, 2)
    S1 = (
         I[r -sh+dh  :H-r -sh+dh   ,r -sw+dw  :W-r -sw+dw]
       + I[r +sh+dh+1:H-r +sh+dh+1,r +sw+dw+1:W-r +sw+dw+1]
       - I[r -sh+dh  :H-r -sh+dh  ,r +sw+dw+1:W-r +sw+dw+1]
       - I[r +sh+dh+1:H-r +sh+dh+1,r -sw+dw  :W-r -sw+dw]
    )
    S2=S-S1
    M1=S1/N1
    M2=S2/N2

    Sb = ((N1*(np.power(M1-M, 2))) + (N2*(np.power(M2-M, 2))))/N
    MAP[r:H-r,r:W-r] = (Sb/St)*np.sign(M2-M1)
    MAP[np.isnan(MAP)]=0
    MAP[np.isinf(MAP)]=0

    return MAP
